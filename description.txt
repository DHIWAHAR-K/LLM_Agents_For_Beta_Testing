# Project File Guide - LLM Agents for Beta Testing

This guide describes each file in plain English so anyone can understand what it does.

## Entry Point & Configuration

**main.py** (Entry Point)
This is the main program you run to start testing. It accepts command line arguments like which persona to use, whether to run multiple agents together, and whether to generate reports. It loads your testing persona from a YAML file, sets up the agents and testing environment, runs the complete testing session, and optionally creates detailed reports showing how well the testing went. Think of this as the control panel where you start and configure your entire testing operation.

**config.py** (Settings Manager)
This file stores all the important settings for the testing framework in one place. It manages which local language models to use, how many testing rounds to run, what performance thresholds to enforce, and safety settings. The settings can be changed through environment variables or a configuration file without touching any code. It uses smart validation to ensure all settings make sense before the program runs.

## Agent Components

**agent.py** (Single Agent)
This file creates one intelligent testing agent that pretends to be a real user. It reads the persona description to understand what kind of user it should act like, looks at what the application is currently showing, and decides what action to take next just like a human would. The agent uses a language model to think through each step and generates realistic user actions like clicking buttons, typing text, or navigating pages.

**multi_agent_router.py** (Committee Routing)
This file manages multiple testing agents working together as a committee. It can coordinate five different language models to make decisions together, using strategies like taking turns, voting on the best action, or trying different agents until one succeeds. When agents disagree, it records the disagreement and uses majority voting to pick the final action, making testing more robust and catching more edge cases.

**orchestrator.py** (Session Coordinator)
This is the conductor that runs the entire testing session from start to finish. It initializes the database, creates the testing agents, runs each turn of interaction, validates every action before executing it, sends actions to the application, records all results and timing information, and handles errors gracefully. Think of it as the project manager ensuring all components work together smoothly.

## Language Model Integration

**llm.py** (Model Wrapper)
This file connects to the local Ollama server running your language models. It sends requests to the models asking them to generate testing actions, handles the technical details of formatting requests and parsing responses, retries failed requests automatically, and ensures responses follow the exact structure needed for testing actions. It acts as a translator between your testing framework and the AI models.

**model_registry.py** (Model Management)
This file keeps track of all five language models available for testing. It stores configuration for each model including temperature settings, safety profiles, and unique identifiers, creates model instances when needed and caches them for efficiency, provides model information for reporting and logging, and allows adding new models easily. It is like a catalog of all available AI assistants.

## Data Models & Loading

**schemas.py** (Data Structures)
This file defines the exact structure of data used throughout the system. It specifies what information a persona contains like name, goals, tone, and personality traits, defines what a testing action looks like with type, target, and additional data, and uses validation to ensure data is always in the correct format. These structures are the common language all components use to communicate.

**persona_loader.py** (YAML Loader)
This file reads persona descriptions from YAML files and converts them into structured data. It opens YAML files safely, validates the persona information is complete and correct, fills in sensible defaults for missing values, and returns ready-to-use persona objects. It makes creating new test personas as simple as writing a text file.

## Validation & Safety

**validators.py** (All Validation Logic)
This comprehensive file contains all the safety and correctness checks for testing actions. It verifies actions have valid types and targets, checks actions match the persona's goals, detects dangerous inputs like SQL injection or cross-site scripting attacks, validates event sequences happen in the correct order, and ensures response times meet performance requirements. It is the quality control department catching problems before they cause issues.

## Application Interaction

**aut_adapter.py** (Application Adapter)
This file executes testing actions on the application under test. Currently it simulates application responses for demonstration purposes, but it is designed to connect to real applications through APIs. It translates testing actions into application commands, measures how long each action takes to complete, captures the application's response for the next decision, and can be extended to control web browsers or mobile apps.

## Data Storage & Analysis

**storage.py** (Database Handler)
This file manages all data persistence using SQLite database. It creates database tables automatically on first run, stores complete session information including personas and settings, logs every testing turn with observations, actions, and timing, records important events like errors and committee votes, and provides query functions to retrieve historical testing data. Everything that happens gets saved here.

**metrics.py** (Metrics Calculator)
This file calculates meaningful statistics about testing performance. It computes task success rate showing how often tests complete successfully, measures robustness by comparing clean versus noisy test runs, calculates safety pass rate for adversarial testing scenarios, tracks performance regression between software versions, and analyzes response time statistics including percentiles and averages. It turns raw test data into actionable insights.

**reporter.py** (Report Generator)
This file creates human-readable reports from testing data. It queries the database for session results, calls metrics calculations for statistical analysis, generates JSON reports with detailed structured data, creates Markdown reports with formatted tables and summaries, and compares different versions for regression testing. It communicates testing results to stakeholders clearly.

## Configuration Files

**config/default.yaml** (Default Persona)
This file describes a standard test user persona used when none is specified. It defines realistic user goals, personality traits, and behavior patterns that the testing agent will emulate.

**config/scenario_demo.yaml** (Demo Scenario)
This file contains the starting state for demonstration testing sessions. It describes what the application shows initially before any testing actions are taken.

**config/.env** (Environment Variables)
This file stores environment-specific settings like which models to use for routing, database paths, and other configuration that changes between development and production.

## Project Documentation

**README.md** (Main Documentation)
This file provides comprehensive documentation for users and developers. It explains what the project does and its key features, shows the complete file structure and organization, provides step-by-step installation instructions including Ollama setup, demonstrates how to run tests in single and multi-agent modes, documents all configuration options and validation checks, and gives examples of different testing scenarios.

**pyproject.toml** (Python Package Configuration)
This file defines the project as a Python package with all dependencies listed. It specifies required libraries like Pydantic, OpenAI client, and YAML parser, sets the minimum Python version needed, enables installation in development mode for easy testing, and provides package metadata like name, version, and description.

**description.txt** (This File)
This file provides plain English descriptions of every file in the project. It helps new users and developers quickly understand the purpose and function of each component without reading code.
